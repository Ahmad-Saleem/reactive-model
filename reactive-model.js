'use strict';

function always(){
  return true;
}


// Constructor function for a directed graph data structure.
function Graph(){
  
  // The adjacency list of the graph.
  // Keys are node ids.
  // Values are adjacent node arrays.
  var edges = {};
  
  // Gets or creates the adjacent node list for node u.
  function adjacent(u){
    return edges[u] || (edges[u] = []);
  }
  
  return {

    adjacent: adjacent,

    addEdge: function (u, v){
      adjacent(u).push(v);
    },

    // TODO test this function
    removeEdge: function (u, v){
      if(edges[u]) {
        edges[u] =  edges[u]
      }
      adjacent(u).push(v);
    },

    // Depth First Search algorithm, inspired by
    // Cormen et al. "Introduction to Algorithms" 3rd Ed. p. 604
    DFS: function (sourceNodes, shouldVisit){

      var visited = {};
      var nodes = [];

      shouldVisit = shouldVisit || always;

      sourceNodes.forEach(function DFSVisit(node){
        if(!visited[node] && shouldVisit(node)){
          visited[node] = true;
          adjacent(node).forEach(DFSVisit);
          nodes.push(node);
        }
      });

      return nodes;
    }
  };
}

var dependencyGraph = new Graph();

var counter = 0;
var makeNode = function (){
  return "" + (counter++);
}

function ReactiveFunction(inProperties, outProperty, callback){
  return {

    // An array of property name strings.
    inProperties: inProperties,

    // A single property name string.
    outProperty: outProperty,

    // function (...inProperties) -> outPropertyValue
    // Invoked when all input properties are defined,
    // at most once each animation frame with most recent values,
    // triggered whenever input properties change.
    callback: callback
  };
}

// This is where the options object passed into `model.react(options)` gets
// transformed into an array of ReactiveFunction instances.
ReactiveFunction.parse = function (options){
  return Object.keys(options).map( function (outProperty){
    var arr = options[outProperty];
    var callback = arr.splice(arr.length - 1)[0];
    var inProperties = arr;
    return ReactiveFunction(inProperties, outProperty, callback);
  });
};


// A simple requestAnimationFrame polyfill.
//
// Inspired by:
//
//   https://github.com/chrisdickinson/raf
//   http://jsmodules.io/
//
// Curran Kelleher June 2015
var nextFrame;
if(typeof requestAnimationFrame === "undefined"){
  nextFrame = setTimeout;
} else {
  nextFrame = requestAnimationFrame;
}
var _nextFrame = nextFrame;


// Queues the given callback function to execute
// on the next animation frame.
function debounce(callback){
  var queued = false;
  return function () {
    if(!queued){
      queued = true;
      _nextFrame(function () {
        queued = false;
        callback();
      });
    }
  };
}

function invoke(callback){
  callback();
}


function SimpleModel(){

  // The internal stored values for tracked properties. { property -> value }
  var values = {};

  // The callback functions for each tracked property. { property -> [callback] }
  var listeners = {};

  function getListeners(property){
    return listeners[property] || (listeners[property] = []);
  }

  function on(property, callback){
    getListeners(property).push(callback);
  };

  function set(property, value){
    setSilently(property, value);
    getListeners(property).forEach(invoke);
  }

  function setSilently(property, value){
    values[property] = value;
  }

  function get(property){
    return values[property];
  }

  return {
    on: on,
    set: set,
    setSilently: setSilently,
    get: get
  };
}

function ReactiveModel(){

  // Enforce use of new.
  // See http://stackoverflow.com/questions/17032749/pattern-for-enforcing-new-in-javascript
  if (!(this instanceof ReactiveModel)) {
    return new ReactiveModel();
  }

  // Refer to `this` (the ReactiveModel instance) as `model` in this closure.
  var model = this;

  // This object tracks the state of tracked properties.
  var simpleModel = new SimpleModel();

  // The set of tracked properties. { property -> true }
  var trackedProperties = {};

  // The set of changed properties for the upcoming digest. { property -> true }
  // Cleared out at the end of each digest.
  var changedProperties = {};

  // The properties set as output by reactive functions in the upcoming digest. { property -> true }
  // Cleared out at the end of each digest.
  var computedProperties = {}
    
  // Keys are property names,
  // values are node identifiers generated by makeNode().
  var propertyNodes = {};

  // Keys are node identifiers,
  // values are reactive functions.
  var reactiveFunctions = {};

  // Gets or creates a graph node for the given property.
  function getPropertyNode(property){
    if(property in propertyNodes){
      return propertyNodes[property];
    } else {
      return (propertyNodes[property] = makeNode());
    }
  }

  // Constructs the object to be passed into reactive function callbacks.
  // Returns an object with values for each inProperty of the given reactive function.
  function inPropertyValues(λ){
    var d = {};
    λ.inProperties.forEach(function (inProperty){
      d[inProperty] = simpleModel.get(inProperty);
    });
    return d;
  }

  // Returns true if all elements of the given array are defined, false otherwise.
  function allAreDefined(arr){
    return !arr.some(function (d) {
      return typeof d === "undefined" || d === null;
    });
  }
  
  function shouldVisit(node){

    // If the node is for a reactive function,
    if(node in reactiveFunctions){
      var λ = reactiveFunctions[node];

      // only visit the node if all input properties are defined,
      var inPropertyDefs = λ.inProperties.map(function (inProperty){

        // or if they are computed by previously visited reactive functions.
        if(inProperty in computedProperties){
          return true;
        } else {
          return simpleModel.get(inProperty);
        }
      });

      var willVisit = allAreDefined(inPropertyDefs);
      
      if(willVisit){
        computedProperties[λ.outProperty] = true;
      }

      return willVisit;
    } else {

      // Visit all property nodes.
      return true;
    }
  }

  var digest = debounce(function (){
    var properties = Object.keys(changedProperties);
    var sourceNodes = properties.map(getPropertyNode);
    var topologicallySorted = dependencyGraph
      .DFS(sourceNodes, shouldVisit)
      .reverse();

    topologicallySorted.forEach(function (node){
      if(node in reactiveFunctions){
        var λ = reactiveFunctions[node];
        var outPropertyValue = λ.callback(inPropertyValues(λ));
        simpleModel.setSilently(λ.outProperty, outPropertyValue);
      }
    });

    changedProperties = {};
    //
    // TODO test
    //computedProperties = {};
  });

  // Tracks a property if it is not already tracked.
  function track(property){
    if(!(property in trackedProperties)){
      trackedProperties[property] = true;

      if(property in model){
        simpleModel.set(property, model[property]);
      }

      Object.defineProperty(model, property, {
        get: function () {
          return simpleModel.get(property);
        },
        set: function(value) {
          return simpleModel.set(property, value);
        }
      });
    }
  }

  model.react = function (options){

    ReactiveFunction.parse(options).forEach(function (λ){

      var λNode = makeNode();
      var outNode = getPropertyNode(λ.outProperty);

      reactiveFunctions[λNode] = λ;
      dependencyGraph.addEdge(λNode, outNode);
      track(λ.outProperty);

      λ.inProperties.forEach(function (inProperty){

        var inNode = getPropertyNode(inProperty);
        dependencyGraph.addEdge(inNode, λNode);

        simpleModel.on(inProperty, function (){
          changedProperties[inProperty] = true;
          digest();
        });

        track(inProperty);
      });
    });

    return reactiveFunctions;
  };

  return model;
}

exports.ReactiveModel = ReactiveModel;
exports.SimpleModel = SimpleModel;
exports.Graph = Graph;
exports.nextFrame = _nextFrame;
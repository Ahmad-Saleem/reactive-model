'use strict';

// Constructor function for a directed graph data structure.
function Graph(){
  
  // The adjacency list of the graph.
  // Keys are node ids.
  // Values are adjacent node arrays.
  var edges = {};
  
  // Gets or creates the adjacent node list for node u.
  function adjacent(u){
    return edges[u] || (edges[u] = []);
  }
  
  return {

    adjacent: adjacent,

    addEdge: function (u, v){
      adjacent(u).push(v);
    },

    // TODO test this function
    removeEdge: function (u, v){
      if(edges[u]) {
        edges[u] =  edges[u]
      }
      adjacent(u).push(v);
    },

    // Depth First Search algorithm, inspired by
    // Cormen et al. "Introduction to Algorithms" 3rd Ed. p. 604
    DFS: function (sourceNodes){

      var visited = {};
      var nodes = [];

      sourceNodes.forEach(function DFSVisit(node){
        if(!visited[node]){
          visited[node] = true;
          adjacent(node).forEach(DFSVisit);
          nodes.push(node);
        }
      });

      return nodes;
    }
  };
}

var dependencyGraph = new Graph();

var counter = 0;
var makeNode = function (){
  return "" + (counter++);
}

function ReactiveFunction(inProperties, outProperty, callback){
  return {

    // An array of property name strings.
    inProperties: inProperties,

    // A single property name string.
    outProperty: outProperty,

    // function (...inProperties) -> outPropertyValue
    // Invoked when all input properties are defined,
    // at most once each animation frame with most recent values,
    // triggered whenever input properties change.
    callback: callback
  };
}

// This is where the options object passed into `model.react(options)` gets
// transformed into an array of ReactiveFunction instances.
ReactiveFunction.parse = function (options){

  var outProperties = Object.keys(options);

  return outProperties.map( function (outProperty){

    var arr = options[outProperty];

    // The first element in the array should be a comma delimited
    // list of input property names.
    var inPropertiesStr = arr[0];
    var inProperties = inPropertiesStr.split(",").map( function (inPropertyStr){
      return inPropertyStr.trim();
    });

    // The second element in the array should be a callback.
    var callback = arr[1]; 

    return ReactiveFunction(inProperties, outProperty, callback);
  });
};

function invoke(callback){
  callback();
}


function SimpleModel(){

  // The internal stored values for tracked properties. { property -> value }
  var values = {};

  // The callback functions for each tracked property. { property -> [callback] }
  var listeners = {};

  function getListeners(property){
    return listeners[property] || (listeners[property] = []);
  }

  function on(property, callback){
    getListeners(property).push(callback);
  };

  function set(property, value){
    values[property] = value;
    getListeners(property).forEach(invoke);
  }

  function get(property){
    return values[property];
  }

  return {
    on: on,
    set: set,
    get: get
  };
}

function ReactiveModel(){

  // Enforce use of new.
  // See http://stackoverflow.com/questions/17032749/pattern-for-enforcing-new-in-javascript
  if (!(this instanceof ReactiveModel)) {
    return new ReactiveModel();
  }

  // Refer to `this` (the ReactiveModel instance) as `model` in this closure.
  var model = this;

  // This object tracks the state of tracked properties.
  var simpleModel = new SimpleModel();

  // The set of tracked properties. { property -> true }
  //var trackedProperties = {};
  model.react = function (options){

    // An array of ReactiveFunction objects parsed from options.
    var reactiveFunctions = ReactiveFunction.parse(options);
    
    // Keys are property names,
    // values are node identifiers generated by makeNode().
    var propertyNodes = {};

    reactiveFunctions.forEach(function (λ){

      var λNode = makeNode();
      var outNode = getPropertyNode(λ.outProperty);

      dependencyGraph.addEdge(λNode, outNode);

      λ.inProperties.forEach(function (inProperty){
        var inNode = getPropertyNode(inProperty);
        dependencyGraph.addEdge(inNode, λNode);
        simpleModel.on(inProperty, function (){

          //changedProperties[inProperty] = true;
        });
      });
    });

    function getPropertyNode(property){
      if(property in propertyNodes){
        return propertyNodes[property];
      } else {
        return (propertyNodes[property] = makeNode());
      }
    }

    //console.log(dependencyGraph.adjacent(0));

    return reactiveFunctions;
  };

  return model;
}


// A simple requestAnimationFrame polyfill.
//
// Inspired by:
//
//   https://github.com/chrisdickinson/raf
//   http://jsmodules.io/
//
// Curran Kelleher June 2015
var nextFrame;
if(typeof requestAnimationFrame === "undefined"){
  nextFrame = setTimeout;
} else {
  nextFrame = requestAnimationFrame;
}
var _nextFrame = nextFrame;

exports.ReactiveModel = ReactiveModel;
exports.SimpleModel = SimpleModel;
exports.Graph = Graph;
exports.nextFrame = _nextFrame;
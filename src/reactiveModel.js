import Graph from "./graph";
import ReactiveFunction from "./reactiveFunction";
import SimpleModel from "./simpleModel";
import nextFrame from "./nextFrame";
import makeNode from "./makeNode";

var dependencyGraph = new Graph();

// Queues the given callback function to execute
// on the next animation frame.
function debounce(callback){
  var queued = false;
  return function () {
    if(!queued){
      queued = true;
      nextFrame(function () {
        queued = false;
        callback();
      });
    }
  };
}

function ReactiveModel(){

  // Enforce use of new.
  // See http://stackoverflow.com/questions/17032749/pattern-for-enforcing-new-in-javascript
  if (!(this instanceof ReactiveModel)) {
    return new ReactiveModel();
  }

  // Refer to `this` (the ReactiveModel instance) as `model` in this closure.
  var model = this;

  // This object tracks the state of tracked properties.
  var simpleModel = new SimpleModel();

  // The set of tracked properties. { property -> true }
  var trackedProperties = {};

  // The set of changed properties. { property -> true }
  var changedProperties = {};
    
  // Keys are property names,
  // values are node identifiers generated by makeNode().
  var propertyNodes = {};

  // Keys are node identifiers,
  // values are reactive functions.
  var reactiveFunctions = {};

  function getPropertyNode(property){
    if(property in propertyNodes){
      return propertyNodes[property];
    } else {
      return (propertyNodes[property] = makeNode());
    }
  }

  // Constructs the object to be passed into reactive function callbacks.
  function inPropertyValues(λ){
    var d = {};
    λ.inProperties.forEach(function (inProperty){
      d[inProperty] = simpleModel.get(inProperty);
    });
    return d;
  }
  
  // TODO test this.
  //function shouldVisit(node){
  //  if(node in reactiveFunctionNodes){
  //    return allAreDefined();
  //  }
  //}
  var digest = debounce(function (){
    var properties = Object.keys(changedProperties);
    var sourceNodes = properties.map(getPropertyNode);
    var topologicallySorted = dependencyGraph
      .DFS(sourceNodes/*, shouldVisit*/)
      .reverse();

    topologicallySorted.forEach(function (node){
      if(node in reactiveFunctions){
        var λ = reactiveFunctions[node];
        var outPropertyValue = λ.callback(inPropertyValues(λ));
        simpleModel.setSilently(λ.outProperty, outPropertyValue);
      }
    });

    //console.log(topologicallySorted);

    // TODO test
    //changedProperties = {};
  });

  // Tracks a property if it is not already tracked.
  function track(property){
    if(!(property in trackedProperties)){
      trackedProperties[property] = true;

      // TODO test this behavior
      //if(property in model){
      //  simpleModel.set(property, model[property]);
      //}

      Object.defineProperty(model, property, {
        get: function () {
          return simpleModel.get(property);
        },
        set: function(value) {
          return simpleModel.set(property, value);
        }
      });
    }
  }

  // The set of tracked properties. { property -> true }
  //var trackedProperties = {};
  model.react = function (options){

    // An array of ReactiveFunction objects parsed from options.
    ReactiveFunction.parse(options).forEach(function (λ){

      var λNode = makeNode();
      var outNode = getPropertyNode(λ.outProperty);

      reactiveFunctions[λNode] = λ;

      dependencyGraph.addEdge(λNode, outNode);

      track(λ.outProperty);

      λ.inProperties.forEach(function (inProperty){

        var inNode = getPropertyNode(inProperty);
        dependencyGraph.addEdge(inNode, λNode);

        simpleModel.on(inProperty, function (){
          changedProperties[inProperty] = true;
          digest();
        });

        track(inProperty);
      });
    });

    return reactiveFunctions;
  };

  return model;
}

export {
  ReactiveModel,

  SimpleModel,
  Graph,
  nextFrame
};

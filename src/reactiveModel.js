import Graph from "./graph";
import ReactiveFunction from "./reactiveFunction";
import SimpleModel from "./simpleModel";

import nextFrame from "./nextFrame";
import makeNode from "./makeNode";

var dependencyGraph = new Graph();

function ReactiveModel(){

  // Enforce use of new.
  // See http://stackoverflow.com/questions/17032749/pattern-for-enforcing-new-in-javascript
  if (!(this instanceof ReactiveModel)) {
    return new ReactiveModel();
  }

  // Refer to `this` (the ReactiveModel instance) as `model` in this closure.
  var model = this;

  // This object tracks the state of tracked properties.
  var simpleModel = new SimpleModel();

  // The set of tracked properties. { property -> true }
  //var trackedProperties = {};
  model.react = function (options){

    // An array of ReactiveFunction objects parsed from options.
    var reactiveFunctions = ReactiveFunction.parse(options);
    
    // Keys are property names,
    // values are node identifiers generated by makeNode().
    var propertyNodes = {};

    reactiveFunctions.forEach(function (λ){

      var λNode = makeNode();
      var outNode = getPropertyNode(λ.outProperty);

      dependencyGraph.addEdge(λNode, outNode);

      λ.inProperties.forEach(function (inProperty){
        var inNode = getPropertyNode(inProperty);
        dependencyGraph.addEdge(inNode, λNode);
        simpleModel.on(inProperty, function (){

          //changedProperties[inProperty] = true;
        });
      });
    });

    function getPropertyNode(property){
      if(property in propertyNodes){
        return propertyNodes[property];
      } else {
        return (propertyNodes[property] = makeNode());
      }
    }

    //console.log(dependencyGraph.adjacent(0));

    return reactiveFunctions;
  };

  return model;
}

export {
  ReactiveModel,

  SimpleModel,
  Graph,
  nextFrame
};
//
//  // Each model gets a unique id.
//  model.id = modelIdCounter++;
//
//}
//
//// Expose internals for unit testing only.
//ReactiveModel.dependencyGraph = dependencyGraph;
//ReactiveModel.encodeReactiveFunction = encodeReactiveFunction;
//ReactiveModel.encodeProperty = encodeProperty;
//
//module.exports = ReactiveModel;
//
////
////function allAreDefined(arr){
////  return !arr.some(isNotDefined);
////}
////
////function isNotDefined(d){
////  return typeof d === 'undefined' || d === null;
////}
////
////function debounce(callback){
////  var queued = false;
////  return function () {
////    if(!queued){
////      queued = true;
////      setTimeout(function () {
////        queued = false;
////        callback();
////      }, 0);
////    }
////  };
////}
////
////export function ReactiveModel(){
////
////  if (!(this instanceof ReactiveModel)) {
////    return new ReactiveModel();
////  }
////
////  var model = this;
////  var values = {};
////  var trackedProperties = {};
////  var reactiveFunctions = {};
////
////  function getReactiveFunctions(inProperty){
////    if( !(inProperty in reactiveFunctions) ){
////      return reactiveFunctions[inProperty] = [];
////    } else {
////      return reactiveFunctions[inProperty];
////    }
////  }
////
////  var invoke = function(reactiveFunction){
////    var args = reactiveFunction.inProperties.map( function (inProperty){
////      return values[inProperty];
////    });
////    if(allAreDefined(args)){
////      reactiveFunction.callback.apply(null, args);
////    }
////  };
////
////  model.react = function (options){
////    Object.keys(options).forEach( function (outProperty){
////
////      var arr = options[outProperty];
////
////      var inPropertiesStr = arr[0];
////      var callback        = arr[1]; 
////
////      var inProperties = inPropertiesStr.split(",").map( function (inPropertyStr){
////        return inPropertyStr.trim();
////      });
////
////      var reactiveFunction = ReactiveFunction(inProperties, outProperty, callback);
////
////      inProperties.forEach(function (inProperty){
////        getReactiveFunctions(inProperty).push(reactiveFunction);
////        track(inProperty);
////      });
////
////      invoke(reactiveFunction);
////    });
////  };
////
////  function track(property){
////    if( !trackedProperties[property] ){
////      trackedProperties[property] = true;
////
////      var previousValue = model[property];
////
////      Object.defineProperty(model, property, {
////        get: function (){
////          return values[property];
////        },
////        set: function (value){
////          values[property] = value;
////          
////          // TODO test this path
////          //getReactiveFunctions(property).forEach(invoke);
////        }
////      });
////
////      if(!isNotDefined(previousValue)){
////        model[property] = previousValue;
////      }
////    }
////  }
////
////  return model;
////};
